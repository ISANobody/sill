(* If is desugared as a case over Bool *)

max : Int -> Int -> Int;;
max a b = if a > b then a else b;;

max : Int -> Int -> Int;;
max a b = case a > b of
          | True -> a
          | False -> b;;

(* Top level monadic bindings are desugared into a top level expression *)
foo : Int -> {1 <- 1};;
'c <- foo n -< 'd =
   wait 'd;
   close 'c;;

foo : Int -> {1 <- 1};;
foo n = 'c <-{ wait 'd;
             close 'c }-< 'd;;

(* Outputing a channel is desugared as spawning a trivial process *)

foo : {1*1 <- 1};;
'c <- foo -< 'd =
  send 'c 'd;
  close 'c;;

foo : {1*1 <- 1};;
'c <- foo -< 'd =
  send 'c ('e <- 'e <- 'd);
  close 'c;;

(* tail-binding is converted adds a temporary channel *)

bar : {1*1 <- 1};;
'c <- bar -< 'd =
  'c <- foo -< 'd;;

bar : {1*1 <- 1};;
'c <- bar -< 'd =
  'e <- foo -< 'd;
  'c <- 'e;;

(* Case/If statements on processes are desugared into monadic expressions *)

foo : Int -> {1 <- 1; 1};;
'c <- foo n -< 'd 'e =
   case n > 0 of
   | True  -> wait 'd;
              wait 'e;
              close 'c
   | False -> wait 'e;
              wait 'd;
              close 'c;;

foo : Int -> {1 <- 1; 1};;
'c <- foo n -< 'd 'e =
   'c <- (case n > 0 of
         | True  -> 'c <-{ wait 'd;
                           wait 'e;
                           close 'c }-< 'd 'e
         | False -> 'c <-{ wait 'e;
                           wait 'd;
                           close 'c }-< 'd 'e) -< 'd 'e;;

(* Let bindings in processes are desugared into monadic expressions *)

foo : {1};;
'c <- foo =
  let x : Int = 5;
  close 'c;;

foo : {1};;
'c <- foo =
  'c <- (let x : Int = 5
         in 'c <- {close 'c});;

(* Sequencing in processes is desugared into let bindings *)

foo : {1};;
'c <- foo =
  print 4;
  close 'c;;

foo : {1};;
'c <- foo =
  let x : () = print 4;
  close 'c;;

(* Mutually recursive functions get desugared into a new type and accessors *)

foo : Int -> Int;;
foo n = n + 1
and
bar : Bool -> Bool;;
bar b = b || b;;

type Foo_Bar_Input  = FooI Int
                    | BarI Bool;;
type Foo_Bar_Output = FooO Int
                    | BarO Bool;;

foo_bar : Foo_Bar_Input -> Foo_Bar_Output;;
foo_bar i = case i of
            | FooI n -> FooO (n + 1)
            | BarI b -> BarO (b || b);;

foo : Int -> Int;;
foo n = case (foo_bar (FooI n)) of
        | FooO o -> o;;

bar : Bool -> Bool;;
bar b = case (foo_bar (BarI b)) of
        | BarO o -> o;;

(* Recursive calls in session type declarations must have identical parameter lists to the
   declaration and are desugared into mu's *)

stype Foo a = a/\ Foo a;;

stype Foo a = mu $x. a/\ $x;;

(* Mix is desugared into to binds *)

'top1 <- close 'top1
and
'top2 <- close 'top2;;

'top <- let m1 : {1} = 'top1 <-{ close 'top1 };
        'm1 <- m1;
        let m2 : {1} = 'top2 <- { close 'top2 };
        'm2 <- m2;
        wait 'm2;
        wait 'm1;
        close 'top;;
