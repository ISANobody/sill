type EvenOdd = Even | Odd ;;
type EvenOddRes = EvenRes ([Int] -> Bool) | OddRes ([Int] -> Bool);;

even_odd_res_even : EvenOddRes -> ([Int] -> Bool);;
even_odd_res_even r = case r of | EvenRes f -> f;;
even_odd_res_odd : EvenOddRes -> ([Int] -> Bool);;
even_odd_res_odd r = case r of | OddRes f -> f;;

even_odd : EvenOdd -> EvenOddRes;;
even_odd m =
  let even l : [Int] -> Bool = even_odd_res_even (even_odd Even) l in 
  let odd l : [Int] -> Bool  = even_odd_res_odd (even_odd Odd) l in
  case m of
  | Even -> EvenRes (fun l -> case l of
                              | [] -> True
                              | _::ls -> odd ls)
  | Odd -> OddRes (fun l -> case l of
                            | [] -> False
                            | _::ls -> even ls)
;;

even : [Int] -> Bool;;
even = even_odd_res_even (even_odd Even);;

odd : [Int] -> Bool;;
odd = even_odd_res_odd (even_odd Odd);;

'top <- print_str (sexp2s (even [1;2;3])); close 'top;;
