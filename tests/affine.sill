atype Stream a = a /\ Stream a;;
atype List a = +{next: a/\ List a; stop: 1};;

nill : { List a };;
@c <- nill =
  @c.stop;
  close @c;;

consl : a -> { List a <- List a };;
@h <- consl a -< @tl =
  @h.next;
  send @h a;
  @h <- @tl;;

'top <- @c <- nill;
        close 'top;;

repeat : a -> { Stream a };;
@c <- repeat a =
  send @c a;
  @c <- repeat a;;

conss : a -> { Stream a <- Stream a};;
@h <- conss a -< @tl =
  send @h a;
  @h <- @tl;;

print_stream : Int -> {1 <- Stream Int};;
'c <- print_stream n -< @s =
   if n = 0
   then close 'c
   else x <- recv @s;
        print x;
        'c <- print_stream (n-1) -< @s;;

'top <- @c <- repeat 5;
        @d <- conss 6 -< @c;
        'top <- print_stream 4 -< @d;;

foo : { 1 <- 1 };;
'c <- foo -< 'd =
  wait 'd;
  close 'c;;

bar : {@1};;
@c <- bar =
  close @c;;

(* Can downcast affine to linear *)
'top <- 'c <- bar;
        'd <- foo -< 'c;
        wait 'd;
        close 'top;;

(* Can downcast via forward *)
slithy : { 1 <- @1 };;
'c <- slithy -< @d =
  'c <- @d;;

'top <- @c <- bar;
        'd <- foo -< @c;
        wait 'd;
        close 'top;;

quux : { 1 <- @1 };;
'c <- quux -< @d =
  close 'c;;

(* Error: passing linear channel as into affine argument *)
(* 'top <- 'c <- bar;
        'd <- quux -< 'c;
        wait 'd;
        close 'top;; *)

baz : {1};;
'c <- baz =
    close 'c;;

(* Error: binding linear monad to affine channel *)
(* 'top <- @c <- baz;
        close 'top;; *)

(* { }I *)
(* No linear arguments when providing affine *)
(* foo : {@1 <- 1};;
foo =
  @c <-{ wait 'd;
         close @c }-< 'd;; *)

(* Must provide affine type with affine channel.
   Removing this restriction should be safe. *)
(* foo : {1};;
foo = @c <-{ close @c};; *)

(* 1L *)
  (* Can wait on an affine channel *)
  foo : {1 <- @1};;
  'c <- foo -< @d =
    wait @d;
    close 'c;;

(* Id *)
  (* Can linearize *)
  foo : {1 <- @1 };;
  'c <- foo -< @d =
    'c <- @d;;

  (* Can't affinize *)
  (* foo : {@1 <- 1 };;
  @c <- foo -< 'd =
    @c <- 'd;; *)
  
(* Bind *)
  (* Can linearize arguments *)
  foo : {1 <- @1};;
  'c <- foo -< @d =
    'e <- <'f <-{ wait 'g; close 'f }-< 'g:{1<-1}> -< @d;
    wait 'e;
    close 'c;;

  (* Can't affinize arguments *)
  (* foo : {1 <- 1};;
  'c <- foo -< 'd =
    'e <- <'f <-{ close 'f }-< @g:{1<-@1}> -< 'd;
    wait 'e;
    close 'c;; *)

  (* Can linearize bound channel *)
  foo : {1};;
  'c <- foo =
     'd <- <@e <-{close @e}:{@1}>;
     wait 'd;
     close 'c;;

  (* Can't affinize bound channel *)
  (* foo : {1};;
  'c <- foo =
     @d <- <'e <-{close 'e}:{1}>;
     close 'c;; *)

(* Tail-bind *)
  (* Can linearize arguments *)
  (* foo : {1 <- @1};;
  'c <- foo -< @d =
    'c <- <'e <-{wait 'f; close 'e}-< 'f: {1<- 1}> -< @d;; *)

  (* Can't affinize arguments *)
  (* foo : {1 <- 1};;
  'c <- foo -< 'd =
    'c <- <'e <-{close 'e}-< @f: {1<- @1}> -< 'd;; *)

  (* Can linearize bound channel *)
  (* foo : {1};;
  'c <- foo =
     'c <- <@e <-{close @e}:{@1}>;; *)

  (* Can't affinize bound channel *)
  (* foo : {@1};;
  @c <- foo =
     @c <- <'e <-{close 'e}:{1}>;; *)

(* =>R *)
(* /\L *)
  (* Affine on the left *)
  foo : {1 <- @(Int /\ 1)};;
  'c <- foo -< @d =
    _ <- recv @d;
    close 'c;;

(* /\R *)
(* =>L *)
  (* Affine on the left *)
  foo : {1 <- @(Int => 1)};;
  'c <- foo -< @d = 
    send @d 4;
    close 'c;;

(* -oR *)
  (* foo : {(@1)-o1};;
  'c <- foo =
    @d <- recv 'c;
    close 'c;; *)

  (* Can't affinize *)
  (* foo : {1-o1};;
  'c <- foo =
    @d <- recv 'c;
    close 'c;; *)

  (* Can't bind linear while in affine context *)
  (* foo : {@(1-o1)};;
  @c <- foo =
    'd <- recv @c;
    wait 'd;
    close @c;;*)

  (* Can bind affine while in affine context *)
  foo : {@(@1-o1)};;
  @c <- foo =
    @d <- recv @c;
    close @c;;

(* (x)L *)
  (* Affine on the left *)
  foo : {1 <- @(1*1)};;
  'c <- foo -< @d = 
    'e <- recv @d;
    wait 'e;
    close 'c;;

  (* Can't affinize *)
  (* foo : {1 <- 1(x)1};;
  'c <- foo -< 'd =
    @e <- recv 'd;
    wait 'd;
    close 'c;; *)

  (* Can't bind linear while in affine context *)
  (* foo : {@1 <- 1(x)1};;
  @c <- foo -< 'e =
    'd <- recv 'e;
    wait 'e;
    wait 'd;
    close @c;; *)

  (* Can bind affine while in affine context *)
  foo : {@1 <- @(@1*1)};;
  @c <- foo -< @e =
    @d <- recv @e;
    wait @e;
    close @c;;

(* (x)R *)

  (* Error: linear channel in affine context *)
  (* foo : {(@1)(x)1 <- @1};;
  'c <- foo -< 'd =
     send 'c (@e <- wait 'd; close @e);
     close 'c;; *)
  
(* -oL *)
  (* Affine on the left *)
  foo : {1 <- @(1-o1)};;
  'c <- foo -< @d =
    send @d ('e <- close 'e);
    close 'c;;

(* &R *)
(* (+)L *)
  (* Affine on the left *)
  foo : {1 <- @+{bar: 1}};;
  'c <- foo -< @d =
    case @d of
    | bar -> close 'c;;

(* (+)R *)
(* &L *)
  (* Affine on the left *)
  foo : {1 <- @(&{bar:1})};;
  'c <- foo -< @d =
     @d.bar;
     close 'c;;

(* !L *)
  (* Affine on the left *)
  foo : {1 <- @(!1)};;
  'c <- foo -< @d =
     !u <- recv @d;
     close 'c;;

(* copy *)
  (* Can't affinize *)
  (* foo : {1 <- !1};;
  'c <- foo -< 'd =
     !u <- recv 'd;
     @e <- copy !u;
     close 'c;;*)

  (* Can't bind linear in affine context *)
   (* foo : {@1 <- @(!1)};;
   @c <- foo -< @d =
      !u <- recv @d;
      'e <- copy !u;
      wait 'e;
      close @c;; *)

(* Tests to confirm that affine processes are actually being garbage collected *)

(* First a process that can be GC'ed.  *)
foo : {@(mu $x. Int /\ $x)};;
@c <- foo =
  send @c 5;
  @c <- foo;;

'top <-  @c <- foo;
         close 'top;;

'top <- @c <- foo;
        _ <- recv @c;
        close 'top;;

branch : {+{red:1; blue:1; green:1}};;
'c <- branch = 'c.blue; close 'c;;

'top <- @c <- foo;
        'd <- branch;
        case 'd of
        | red -> wait 'd; close 'top
        | blue -> wait 'd; close 'top
        | green -> wait 'd; close 'top;;

'top <- @c <- foo;
        'd <- branch;
        case 'd of
        | red -> _ <- recv @c; wait 'd; close 'top
        | blue -> wait 'd; close 'top
        | green -> wait 'd; close 'top;;


(* The sleep here is a chance to let GC'ed processes to make themselves known *)
'top <- sleep 1; close 'top;;
