(* We don't have a wide enough tuple construct, so we make something *)
type Quad = Quad Int AESKey String String;;

stype NSServer = String => String => Int => (* A->S: A,B,N_A *)
                   String /\  (* S -> A: {N_A,K_AB,B,{K_AB,A}_(K_BS)}_(K_AS) *)
                   NSServer;;

service NSServer = NSServer;;

server: AESKey -> AESKey -> {NSServer};;
's <- server kas kbs =
  a  <- recv 's;
  b  <- recv 's;
  na <- recv 's;
  let kab : AESKey = aeskey ();
  send 's (aesenc (Quad na kab b (aesenc (kab,a) kbs)) kas);
  's <- server kas kbs;;

alice: AESKey -> {1 <- String => String /\ String => 1};;
'a <- alice kas -< 'b =
  's <- service NSServer;
  let nonce : Int = 4;
  send 's "Alice";
  send 's "Bob";
  send 's nonce;
  m <- recv 's;
  register NSServer 's;
  case aesdec m kas of
  | Quad na kab b m' -> 
    assert (b = "Bob");
    assert (na = nonce);
    send 'b m';
    nbkab <- recv 'b;
    send 'b (aesenc (aesdec nbkab kab - 1) kab);
    wait 'b;
    close 'a;;

bob: AESKey -> {String => String /\ String => 1};;
'b <- bob kbs =
  let nb : Int = 42;
  m <- recv 'b;
  let kab : AESKey = case (aesdec m kbs) of | (x,_) -> x;
  send 'b (aesenc nb kab);
  m' <- recv 'b;
  assert (aesdec m' kab = 41);
  print_str "Bob successfully checked nonce.\n";
  close 'b;;

'top <-
 let kas : AESKey = aeskey ();
 let kbs : AESKey = aeskey ();
 's <- server kas kbs;
 register NSServer 's;
 'b <- bob kbs;
 'a <- alice kas -< 'b;
 wait 'a;
 close 'top;;
